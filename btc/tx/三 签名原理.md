#### 签名的作用是为了解决如下问题：
发送方发送一段数据。接受方接受到之后，如果确保1:数据没有被篡改，2:输入来源于真实发送方，而不是其他人

#### Solution:
1. 利用Hash的低碰撞率确保数据没有被篡改。把发送的数据通过hash算法生成一段摘要，把摘要一起发送给接受方，接受方接受到数据和摘要之后。通过对数据进行相同的hash算法，比较生成的摘要和接受到的摘要是否相等，来判断数据是否被篡改
2. 摘要不能被直接传输，避免被第三方截取修改。利用非对称加密算法，发送方拥有私钥，接受方拥有公钥。发送方利用私钥对摘要进行加密。接受方利用公钥进行验证。

#### 综上所述，数字签名中需要以下几种角色的参与：
1. 原始数据
2. 原始数据摘要
3. 发送方私钥（发送方持有）
4. 发送方公钥（接受方持有）


#### 具体到比特币中，也需要解决以上问题。1.要确保交易内容不被更改。2. 要确保花费交易的接受方，能够唯一对应上一笔交易的发送方。
因此非对称加密和签名的算法完美应用于比特币。

 #### 各角色对应的数据为：
（摘要算法采用的是sha256）
（非对称加密算法采用的是ecdsa。其中ecdsa需要一条椭圆曲线，采用的椭圆曲线为SECP256k1）
1. 原始数据			tx数据
2. 原始数据摘要		对数据两次sha256的结果
3. 发送方私钥（发送方持有）	ecsda生成的随机私钥，保存在钱包中
4. 发送方公钥（接受方持有）	有私钥生成的公钥，经过封装后变成比特币地址，具体参照第一节

#### 发送方签名的过程如下（输入tx数据，privateKey）：
* digest = sha256(tx数据）
* sig = signature(digest , privateKey)
* scriptSig = DER(sig)

#### 接受方验证过程如下,(输入tx数据，pubKey, scriptSig)：
* digest = sha256(tx数据）
* sig=DER解码（scriptSig）
* VerifySignature(sig, pubKey, digest)

#### 每个Txin都有一个签名字段。也就是每个输入都要签名一次。一个tx如果包含N笔输入，就要对tx进行N次签名，签名的结果分别写入各Txin对应的scriptSig字段。

#### tx数据包含很多部分，输入输出，locktime等，在构建摘要digest = sha256(tx数据）的过程中，可以指定对tx的指定部分进行摘要，通过设置Signature Hash Types，可以对tx数据的指定部分进行摘要。

#### 目前有以下Hash类型：
* SIGHASH_ALL 
* SIGHASH_NONE 
* SIGHASH_SINGLE 
* SIGHASH_ANYONECANPAY
